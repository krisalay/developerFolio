{"status":"ok","feed":{"url":"https://medium.com/feed/@krisalay","title":"Stories by Krisalay on Medium","link":"https://medium.com/@krisalay?source=rss-207c206a9cff------2","author":"","description":"Stories by Krisalay on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*T2CUDqWwjB9_tLIlZ8R12A.png"},"items":[{"title":"Understanding Hash Tables","pubDate":"2023-11-23 09:31:24","link":"https://medium.com/@krisalay/understanding-hash-tables-bbb291855d6e?source=rss-207c206a9cff------2","guid":"https://medium.com/p/bbb291855d6e","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*J4eqbAlgbWqeFGdzFrP6CA.jpeg","description":"\n<h4>A Deep\u00a0Dive</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*J4eqbAlgbWqeFGdzFrP6CA.jpeg\"></figure><p>Hash tables, also known as hash maps, unordered maps, dictionaries, or objects in various programming languages, are a fundamental data structure that plays a crucial role in computer science. In this blog post, we\u2019ll explore the concept of hash tables, their significance, and the underlying mechanisms that make them powerful tools for efficient data storage and retrieval.</p>\n<h3>Introduction to Hash\u00a0Tables</h3>\n<p>Hash tables are widely used in different programming languages, each with its own name\u200a\u2014\u200adictionaries in Python, maps in Golang and Java, hashes in Ruby, and objects in JavaScript. Regardless of the name, the fundamental idea remains the same: a data structure that allows for efficient storage and retrieval of key-value pairs.</p>\n<h3>The Need for Hash\u00a0Tables</h3>\n<p>Arrays and hash tables are frequently discussed topics in technical interviews, and they are essential to understand in the world of programming. Almost every programming language provides a built-in implementation of hash tables. These data structures are extensively used in databases, caches, and various other scenarios where fast and efficient data access is critical.</p>\n<h3>Basic Concepts</h3>\n<p>Let\u2019s start with a simple analogy. Imagine you\u2019re grocery shopping, and you want to add grapes to your basket. If you were to use an array, you\u2019d assign an index to the grapes, like basket[0] = 10000. In contrast, with a hash table, you get to use a key-value pair, such as basket[\"grapes\"] = 10000. This immediately demonstrates the flexibility and readability that hash tables\u00a0offer.</p>\n<h3>How Hash Tables\u00a0Work</h3>\n<p>The core idea behind hash tables is to use a hash function to determine the index where a value should be stored in memory. This hash function takes a key as input and produces a fixed-length value, which serves as the\u00a0index.</p>\n<h3>Hash Functions</h3>\n<p>A hash function is a critical component of hash tables. It takes an input (the key) and generates a fixed-length value. Think of it like an MD5 or SHA256 generator, where the same input always produces the same output. Key aspects of hash functions include:</p>\n<ol>\n<li>One-way Operation: You can\u2019t reverse the process; given the hash value, you can\u2019t determine the original\u00a0input.</li>\n<li>Consistency: The same input always produces the same output, providing an idempotent quality.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/335/1*MIDF18OY0e1aJRiSGm0UEg.png\"></figure><h3>Practical Example</h3>\n<p>Consider the MD5 hash function. If we input the string \u201chello,\u201d it produces the hash 5d41402abc4b2a76b9719d911017c592. The gibberish output is what makes hash functions useful for mapping keys to\u00a0indices.</p>\n<h3>The Power of Hash\u00a0Tables</h3>\n<p>Hash tables enable fast data access because you only need to pass a key through the hash function to immediately locate the corresponding value in memory. While the hash function might seem like a black box, its efficiency is crucial for maintaining fast performance in adding or retrieving properties.</p>\n<h3>Hash Table Complexities</h3>\n<p>The efficiency of hash tables is reflected in their time complexities:</p>\n<ul>\n<li>Insert: O(1)</li>\n<li>Lookup: O(1)</li>\n<li>Delete: O(1)</li>\n<li>Search: O(1)</li>\n</ul>\n<p>These complexities highlight the constant time required for these operations, making hash tables a preferred choice in scenarios where quick access to data is\u00a0crucial.</p>\n<h3>Conclusion</h3>\n<p>In conclusion, hash tables are a powerful and versatile data structure widely used in various programming languages. Understanding their underlying concepts, including hash functions and key-value pairs, is essential for effective programming and success in technical interviews. The efficient time complexities of hash tables make them invaluable in scenarios where fast data access is a priority, such as databases and caches. With this knowledge, you\u2019re well-equipped to leverage hash tables in your programming endeavors.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bbb291855d6e\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h4>A Deep\u00a0Dive</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*J4eqbAlgbWqeFGdzFrP6CA.jpeg\"></figure><p>Hash tables, also known as hash maps, unordered maps, dictionaries, or objects in various programming languages, are a fundamental data structure that plays a crucial role in computer science. In this blog post, we\u2019ll explore the concept of hash tables, their significance, and the underlying mechanisms that make them powerful tools for efficient data storage and retrieval.</p>\n<h3>Introduction to Hash\u00a0Tables</h3>\n<p>Hash tables are widely used in different programming languages, each with its own name\u200a\u2014\u200adictionaries in Python, maps in Golang and Java, hashes in Ruby, and objects in JavaScript. Regardless of the name, the fundamental idea remains the same: a data structure that allows for efficient storage and retrieval of key-value pairs.</p>\n<h3>The Need for Hash\u00a0Tables</h3>\n<p>Arrays and hash tables are frequently discussed topics in technical interviews, and they are essential to understand in the world of programming. Almost every programming language provides a built-in implementation of hash tables. These data structures are extensively used in databases, caches, and various other scenarios where fast and efficient data access is critical.</p>\n<h3>Basic Concepts</h3>\n<p>Let\u2019s start with a simple analogy. Imagine you\u2019re grocery shopping, and you want to add grapes to your basket. If you were to use an array, you\u2019d assign an index to the grapes, like basket[0] = 10000. In contrast, with a hash table, you get to use a key-value pair, such as basket[\"grapes\"] = 10000. This immediately demonstrates the flexibility and readability that hash tables\u00a0offer.</p>\n<h3>How Hash Tables\u00a0Work</h3>\n<p>The core idea behind hash tables is to use a hash function to determine the index where a value should be stored in memory. This hash function takes a key as input and produces a fixed-length value, which serves as the\u00a0index.</p>\n<h3>Hash Functions</h3>\n<p>A hash function is a critical component of hash tables. It takes an input (the key) and generates a fixed-length value. Think of it like an MD5 or SHA256 generator, where the same input always produces the same output. Key aspects of hash functions include:</p>\n<ol>\n<li>One-way Operation: You can\u2019t reverse the process; given the hash value, you can\u2019t determine the original\u00a0input.</li>\n<li>Consistency: The same input always produces the same output, providing an idempotent quality.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/335/1*MIDF18OY0e1aJRiSGm0UEg.png\"></figure><h3>Practical Example</h3>\n<p>Consider the MD5 hash function. If we input the string \u201chello,\u201d it produces the hash 5d41402abc4b2a76b9719d911017c592. The gibberish output is what makes hash functions useful for mapping keys to\u00a0indices.</p>\n<h3>The Power of Hash\u00a0Tables</h3>\n<p>Hash tables enable fast data access because you only need to pass a key through the hash function to immediately locate the corresponding value in memory. While the hash function might seem like a black box, its efficiency is crucial for maintaining fast performance in adding or retrieving properties.</p>\n<h3>Hash Table Complexities</h3>\n<p>The efficiency of hash tables is reflected in their time complexities:</p>\n<ul>\n<li>Insert: O(1)</li>\n<li>Lookup: O(1)</li>\n<li>Delete: O(1)</li>\n<li>Search: O(1)</li>\n</ul>\n<p>These complexities highlight the constant time required for these operations, making hash tables a preferred choice in scenarios where quick access to data is\u00a0crucial.</p>\n<h3>Conclusion</h3>\n<p>In conclusion, hash tables are a powerful and versatile data structure widely used in various programming languages. Understanding their underlying concepts, including hash functions and key-value pairs, is essential for effective programming and success in technical interviews. The efficient time complexities of hash tables make them invaluable in scenarios where fast data access is a priority, such as databases and caches. With this knowledge, you\u2019re well-equipped to leverage hash tables in your programming endeavors.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bbb291855d6e\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["algorithms","programming","algorithmic-efficiency","data-structures","hash-table"]},{"title":"Google Software Engineer Solve an Engineering Problem","pubDate":"2023-11-21 18:33:54","link":"https://medium.com/@krisalay/google-software-engineer-solve-an-engineering-problem-c8e797a9a475?source=rss-207c206a9cff------2","guid":"https://medium.com/p/c8e797a9a475","author":"Krisalay","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c8e797a9a475","description":"\n<p>This blog provides an in-depth exploration of the problem-solving thought process, unraveling solutions to entirely unfamiliar challenges. For a detailed explanation of a Google engineer\u2019s problem-solving approach, refer to this insightful <a href=\"https://youtu.be/XKu_SEDAykw\">video</a>.</p>\n<h4>GitHub Link</h4>\n<p><a href=\"https://github.com/krisalay/ds-algo-golang/blob/main/section-4/google-interview-exercise/google-interview.md\">ds-algo-golang/section-4/google-interview-exercise/google-interview.md at main \u00b7 krisalay/ds-algo-golang</a></p>\n<h3>Problem Statement</h3>\n<p>Identify pairs within a collection where the sum equals a specified target. [1, 2, 3, 9] sum = 8 <br>[1, 2, 4, 4] sum =\u00a08</p>\n<h3>Jot Down\u00a0Details</h3>\n<ol>\n<li>How are these collections given\u200a\u2014\u200ain memory or array or something else? <strong><em>Response:</em></strong><em> Array and assume that the array is sorted in ascending order</em>\n</li>\n<li>What about the repeated element in the array? Can we use the same index twice? <strong><em>Response:</em></strong><em> The same index cannot be used twice, but the same number can appear at different indices. For instance 4 and 4 at indices 2 and 3 in the second example provided.</em>\n</li>\n<li>How about the elements of the array, are they integers or floating points? <strong><em>Response: </em></strong><em>The elements are integers.</em>\n</li>\n<li>Can the numbers be negative? <strong><em>Response:</em></strong><em> Negatives could\u00a0happen.</em>\n</li>\n</ol>\n<h3>Brute Force\u00a0Approach</h3>\n<p>The most straightforward approach involves comparing every conceivable pair, achieved by implementing a nested for-loop. The outer loop starts from the 0th index, while the inner loop begins from the 1st index, systematically checking each pair to determine if their sum equals the target value. While not the most efficient method, this serves as one viable solution to the\u00a0problem.</p>\n<h3>Binary Search\u00a0Approach</h3>\n<p>Iterating through each element in the array, we check if its complement exists. For example, in the first array, the complement of 1 is 8\u20131, i.e., 7. Leveraging the array\u2019s sorted nature, we employ binary search to ascertain the existence of 7. If found, we\u2019ve identified a pair. This method, with a binary search time complexity of O(logn) and an O(n) for-loop, offers an improvement over quadratic approaches, resulting in an O(nlogn) complexity. While efficient, it\u2019s worth noting that this approach may be comparatively slower.</p>\n<p><em>Hint: Instead of doing a binary search, which is uni-directional, what if we start with a pair of numbers to begin with and then work our way inward from\u00a0there?</em></p>\n<h3>Two Pointer\u00a0Approach</h3>\n<p>Assuming the left pointer starts at the 0th index and the right pointer at length-1, we evaluate the sum of their corresponding values. If the sum exceeds the target value, we shift the right pointer leftward by one index. Conversely, if the sum is less than the target, we move the left pointer rightward by one index. This process continues until the sum matches the target or the two pointers converge at a single index. This linear approach ensures an efficient solution with a time complexity of\u00a0O(n).</p>\n<h4>Code:</h4>\n<pre>func  hasPairWithSumInSortedArray(arr []int, target int) bool {<br>  left, right  :=  0, len(arr)-1<br>  for left &lt; right {<br>    sum  := arr[left] + arr[right]<br>    if sum == target {<br>      return  true<br>    } else  if sum &gt; target {<br>      right--<br>    } else {<br>      left++<br>    }<br>  } <br>  // If no pair is found<br>  return  false<br>}</pre>\n<blockquote><em>Let\u2019s make this a bit more difficult. How will you solve this same problem if that array is not\u00a0sorted?</em></blockquote>\n<h3>Array is Not Sorted\u00a0Anymore</h3>\n<p>The first thing course we can think of is first sort the array, then we can solve the problem in the same way as above, but it still will be an O(nlogn) solution. But we want faster than\u00a0that.</p>\n<p>Instead of inquiring, \u2018Is there anywhere?\u2019 we shift our perspective to, \u2018Have I seen it in the past?\u2019 For instance, traversing the first array at index 2 with a value of 3, the complement is 8\u20133, i.e., 5. The crucial step is to check if we\u2019ve encountered 5 before. To efficiently track this, we employ a data structure suitable for lookups, such as a hash set, ensuring constant time lookup. We insert a 7 when encountering a 1 and a 6 when seeing a 2\u200a\u2014\u200aeffectively storing the complements. The careful handling of repeated elements is essential; checking before insertion ensures a seamless\u00a0process.</p>\n<p>Time Complexity: O(n)<br>Space Complexity: O(n)</p>\n<h4>Code:</h4>\n<pre>func  hasPairWithSum(arr []int, target int) bool {<br>  compliments  :=  make(map[int]bool)<br>  for  _, num  :=  range arr {<br>    compliment  := target - num<br>    if compliments[compliment] {<br>      return  true<br>    }<br>    compliments[compliment] =  true<br>  }<br>  return  false<br>}</pre>\n<h3>Array is\u00a0Large</h3>\n<p>What would we do differently if say we have 10 million integers in the array? Questions</p>\n<ol><li>Does the array fit in the memory? <em>Response: No, the array does not fit in the\u00a0memory.</em>\n</li></ol>\n<p>If our hash map fits in memory, but the input does not fit in memory, then we can sort of process it in\u00a0chunks.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c8e797a9a475\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>This blog provides an in-depth exploration of the problem-solving thought process, unraveling solutions to entirely unfamiliar challenges. For a detailed explanation of a Google engineer\u2019s problem-solving approach, refer to this insightful <a href=\"https://youtu.be/XKu_SEDAykw\">video</a>.</p>\n<h4>GitHub Link</h4>\n<p><a href=\"https://github.com/krisalay/ds-algo-golang/blob/main/section-4/google-interview-exercise/google-interview.md\">ds-algo-golang/section-4/google-interview-exercise/google-interview.md at main \u00b7 krisalay/ds-algo-golang</a></p>\n<h3>Problem Statement</h3>\n<p>Identify pairs within a collection where the sum equals a specified target. [1, 2, 3, 9] sum = 8 <br>[1, 2, 4, 4] sum =\u00a08</p>\n<h3>Jot Down\u00a0Details</h3>\n<ol>\n<li>How are these collections given\u200a\u2014\u200ain memory or array or something else? <strong><em>Response:</em></strong><em> Array and assume that the array is sorted in ascending order</em>\n</li>\n<li>What about the repeated element in the array? Can we use the same index twice? <strong><em>Response:</em></strong><em> The same index cannot be used twice, but the same number can appear at different indices. For instance 4 and 4 at indices 2 and 3 in the second example provided.</em>\n</li>\n<li>How about the elements of the array, are they integers or floating points? <strong><em>Response: </em></strong><em>The elements are integers.</em>\n</li>\n<li>Can the numbers be negative? <strong><em>Response:</em></strong><em> Negatives could\u00a0happen.</em>\n</li>\n</ol>\n<h3>Brute Force\u00a0Approach</h3>\n<p>The most straightforward approach involves comparing every conceivable pair, achieved by implementing a nested for-loop. The outer loop starts from the 0th index, while the inner loop begins from the 1st index, systematically checking each pair to determine if their sum equals the target value. While not the most efficient method, this serves as one viable solution to the\u00a0problem.</p>\n<h3>Binary Search\u00a0Approach</h3>\n<p>Iterating through each element in the array, we check if its complement exists. For example, in the first array, the complement of 1 is 8\u20131, i.e., 7. Leveraging the array\u2019s sorted nature, we employ binary search to ascertain the existence of 7. If found, we\u2019ve identified a pair. This method, with a binary search time complexity of O(logn) and an O(n) for-loop, offers an improvement over quadratic approaches, resulting in an O(nlogn) complexity. While efficient, it\u2019s worth noting that this approach may be comparatively slower.</p>\n<p><em>Hint: Instead of doing a binary search, which is uni-directional, what if we start with a pair of numbers to begin with and then work our way inward from\u00a0there?</em></p>\n<h3>Two Pointer\u00a0Approach</h3>\n<p>Assuming the left pointer starts at the 0th index and the right pointer at length-1, we evaluate the sum of their corresponding values. If the sum exceeds the target value, we shift the right pointer leftward by one index. Conversely, if the sum is less than the target, we move the left pointer rightward by one index. This process continues until the sum matches the target or the two pointers converge at a single index. This linear approach ensures an efficient solution with a time complexity of\u00a0O(n).</p>\n<h4>Code:</h4>\n<pre>func  hasPairWithSumInSortedArray(arr []int, target int) bool {<br>  left, right  :=  0, len(arr)-1<br>  for left &lt; right {<br>    sum  := arr[left] + arr[right]<br>    if sum == target {<br>      return  true<br>    } else  if sum &gt; target {<br>      right--<br>    } else {<br>      left++<br>    }<br>  } <br>  // If no pair is found<br>  return  false<br>}</pre>\n<blockquote><em>Let\u2019s make this a bit more difficult. How will you solve this same problem if that array is not\u00a0sorted?</em></blockquote>\n<h3>Array is Not Sorted\u00a0Anymore</h3>\n<p>The first thing course we can think of is first sort the array, then we can solve the problem in the same way as above, but it still will be an O(nlogn) solution. But we want faster than\u00a0that.</p>\n<p>Instead of inquiring, \u2018Is there anywhere?\u2019 we shift our perspective to, \u2018Have I seen it in the past?\u2019 For instance, traversing the first array at index 2 with a value of 3, the complement is 8\u20133, i.e., 5. The crucial step is to check if we\u2019ve encountered 5 before. To efficiently track this, we employ a data structure suitable for lookups, such as a hash set, ensuring constant time lookup. We insert a 7 when encountering a 1 and a 6 when seeing a 2\u200a\u2014\u200aeffectively storing the complements. The careful handling of repeated elements is essential; checking before insertion ensures a seamless\u00a0process.</p>\n<p>Time Complexity: O(n)<br>Space Complexity: O(n)</p>\n<h4>Code:</h4>\n<pre>func  hasPairWithSum(arr []int, target int) bool {<br>  compliments  :=  make(map[int]bool)<br>  for  _, num  :=  range arr {<br>    compliment  := target - num<br>    if compliments[compliment] {<br>      return  true<br>    }<br>    compliments[compliment] =  true<br>  }<br>  return  false<br>}</pre>\n<h3>Array is\u00a0Large</h3>\n<p>What would we do differently if say we have 10 million integers in the array? Questions</p>\n<ol><li>Does the array fit in the memory? <em>Response: No, the array does not fit in the\u00a0memory.</em>\n</li></ol>\n<p>If our hash map fits in memory, but the input does not fit in memory, then we can sort of process it in\u00a0chunks.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c8e797a9a475\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["coding-interview-problems","google-interview","pair-sum-problem","data-structures","algorithms"]},{"title":"Google Interview Exercise","pubDate":"2023-11-21 12:03:25","link":"https://medium.com/@krisalay/google-interview-exercise-a7bcd3f15ff1?source=rss-207c206a9cff------2","guid":"https://medium.com/p/a7bcd3f15ff1","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*ay1R0gybsgN9VS3D1b9V8A.jpeg","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ay1R0gybsgN9VS3D1b9V8A.jpeg\"></figure><p>Let\u2019s embark on an engaging exercise. Instead of simply absorbing information, I encourage you to leverage the provided cheat sheet found at the end of this blog. This cheat sheet outlines a comprehensive 15-step guide for approaching coding interviews. Your task is to complement this guide with insights from a remarkable 24-minute video produced by Google. While the video may involve coding in C++ and could include intricate language, the primary objective is for you to observe how the interviewee in the video aligns with each step in the provided cheat sheet. These steps encapsulate the optimal approach to problem-solving during a coding interview.</p>\n<a href=\"https://medium.com/media/98307ea0780c1f8e29bb3c2e0bd7c609/href\">https://medium.com/media/98307ea0780c1f8e29bb3c2e0bd7c609/href</a><h4>Cheat Sheet</h4>\n<ol>\n<li>When the interviewer presents the question, meticulously jot down key details at the top to showcase organizational skills and attention to\u00a0detail.</li>\n<li>Double-check inputs and outputs to understand the most crucial values and goals of the problem, guiding your approach effectively.</li>\n<li>Pinpoint the central problem, considering aspects like time, space, and memory requirements, demonstrating a focused and goal-oriented mindset.</li>\n<li>Avoid overwhelming the interviewer with numerous questions; instead, seek clarity on vital aspects to demonstrate your problem-solving thought\u00a0process.</li>\n<li>Begin with a straightforward, brute-force approach, showcasing your ability to think critically and present a basic solution conceptually.</li>\n<li>Acknowledge the shortcomings of the naive approach, citing reasons such as higher time complexity or lack of readability.</li>\n<li>Walk through your refined approach, highlighting any potential bottlenecks, repetitions, or unnecessary work. Focus on improving the most significant Big O bottleneck.</li>\n<li>Outline the steps you\u2019ll follow before delving into coding, ensuring a clear and structured approach to problem-solving.</li>\n<li>Emphasize modularization from the start, breaking down your code into comprehensible sections and using comments strategically.</li>\n<li>Initiate coding only when thoroughly prepared and confident about your approach. Knowing your path enhances your performance during whiteboard interviews.</li>\n<li>Anticipate potential errors and challenges in your code. Always validate inputs, assuming users might attempt to break your solution. Discuss how you\u2019d safeguard against\u00a0misuse.</li>\n<li>Use clear and meaningful variable names, avoiding ambiguous choices like i and j. Prioritize code readability to enhance understanding.</li>\n<li>Rigorously test your code against various scenarios, including edge cases, null values, and large datasets. Proactively identify potential issues and ask for permission to assume scenarios for\u00a0testing.</li>\n<li>Engage in a constructive dialogue with the interviewer about possible enhancements. Discuss readability, alternative approaches, and avenues for performance improvement.</li>\n<li>Be prepared for extension questions, especially those related to handling large datasets or input streams. Embrace a divide-and-conquer approach, illustrating your understanding of distributed processing and scalability considerations.</li>\n</ol>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a7bcd3f15ff1\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ay1R0gybsgN9VS3D1b9V8A.jpeg\"></figure><p>Let\u2019s embark on an engaging exercise. Instead of simply absorbing information, I encourage you to leverage the provided cheat sheet found at the end of this blog. This cheat sheet outlines a comprehensive 15-step guide for approaching coding interviews. Your task is to complement this guide with insights from a remarkable 24-minute video produced by Google. While the video may involve coding in C++ and could include intricate language, the primary objective is for you to observe how the interviewee in the video aligns with each step in the provided cheat sheet. These steps encapsulate the optimal approach to problem-solving during a coding interview.</p>\n<a href=\"https://medium.com/media/98307ea0780c1f8e29bb3c2e0bd7c609/href\">https://medium.com/media/98307ea0780c1f8e29bb3c2e0bd7c609/href</a><h4>Cheat Sheet</h4>\n<ol>\n<li>When the interviewer presents the question, meticulously jot down key details at the top to showcase organizational skills and attention to\u00a0detail.</li>\n<li>Double-check inputs and outputs to understand the most crucial values and goals of the problem, guiding your approach effectively.</li>\n<li>Pinpoint the central problem, considering aspects like time, space, and memory requirements, demonstrating a focused and goal-oriented mindset.</li>\n<li>Avoid overwhelming the interviewer with numerous questions; instead, seek clarity on vital aspects to demonstrate your problem-solving thought\u00a0process.</li>\n<li>Begin with a straightforward, brute-force approach, showcasing your ability to think critically and present a basic solution conceptually.</li>\n<li>Acknowledge the shortcomings of the naive approach, citing reasons such as higher time complexity or lack of readability.</li>\n<li>Walk through your refined approach, highlighting any potential bottlenecks, repetitions, or unnecessary work. Focus on improving the most significant Big O bottleneck.</li>\n<li>Outline the steps you\u2019ll follow before delving into coding, ensuring a clear and structured approach to problem-solving.</li>\n<li>Emphasize modularization from the start, breaking down your code into comprehensible sections and using comments strategically.</li>\n<li>Initiate coding only when thoroughly prepared and confident about your approach. Knowing your path enhances your performance during whiteboard interviews.</li>\n<li>Anticipate potential errors and challenges in your code. Always validate inputs, assuming users might attempt to break your solution. Discuss how you\u2019d safeguard against\u00a0misuse.</li>\n<li>Use clear and meaningful variable names, avoiding ambiguous choices like i and j. Prioritize code readability to enhance understanding.</li>\n<li>Rigorously test your code against various scenarios, including edge cases, null values, and large datasets. Proactively identify potential issues and ask for permission to assume scenarios for\u00a0testing.</li>\n<li>Engage in a constructive dialogue with the interviewer about possible enhancements. Discuss readability, alternative approaches, and avenues for performance improvement.</li>\n<li>Be prepared for extension questions, especially those related to handling large datasets or input streams. Embrace a divide-and-conquer approach, illustrating your understanding of distributed processing and scalability considerations.</li>\n</ol>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a7bcd3f15ff1\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["interview-preparation","google-interview","coding-interviews","problem-solving"]},{"title":"Navigating Coding Interviews: The Essential Toolkit","pubDate":"2023-11-21 11:32:39","link":"https://medium.com/@krisalay/navigating-coding-interviews-the-essential-toolkit-04ac10678496?source=rss-207c206a9cff------2","guid":"https://medium.com/p/04ac10678496","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/800/1*PkTH7CqIysUxjP-hB717vg.jpeg","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*PkTH7CqIysUxjP-hB717vg.jpeg\"></figure><p>Embarking on the journey of coding interviews can be both exciting and daunting. To succeed, it\u2019s crucial to focus on the right toolkit of data structures and algorithms. In this comprehensive guide, we\u2019ll explore the must-know elements that form the backbone of coding interviews:</p>\n<h4>Data Structures</h4>\n<ol>\n<li>Arrays</li>\n<li>Stacks</li>\n<li>Queues</li>\n<li>Linked Lists</li>\n<li>Trees</li>\n<li>Tries</li>\n<li>Graphs</li>\n<li>Hash Tables</li>\n</ol>\n<h4>Algorithms</h4>\n<ol>\n<li>Sorting</li>\n<li>Dynamic Programming</li>\n<li>BFS + DFS (Searching)</li>\n<li>Recursion</li>\n</ol>\n<p>There are a lot more data structures and algorithms than this. But just like when you learn a new language, you don\u2019t read through the dictionary and learn every single word in that dictionary and that language. Instead, you focus on being able to communicate with others. You only focus on things that are being used most of the\u00a0time.</p>\n<p>When it comes to data structures and algorithms, the above are the ones where you\u2019re going to be asked in interviews because these are the ones being used the most. 90% of the time to solve a real complex problem you are only going to use these. All you need is the baseline skills, and companies just want to know that you are prepared for the interview and can succeed within their\u00a0system.</p>\n<p>A lot of people complain about coding interviews or whiteboard interviews and how useless they are because they never use some of these algorithms or data structures in their day-to-day jobs. But they are just a way to weed out people who aren\u2019t willing to work hard for an interview. Look at this as an advantage, not many people work on their interview questions. You are going to work harder than 99% of people out there because you know that getting a good job will have a big impact on your\u00a0life.</p>\n<p>The good news is that it\u2019s not as hard as you think. You just have to put your time and effort into the right things. We just need to learn the right data structures &amp; algorithms, when and why to use them, how to implement them, how to solve problems with them, and make code readable, memory efficient, and time efficient using Big O. That\u2019s all coding interviews ask\u00a0for.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=04ac10678496\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*PkTH7CqIysUxjP-hB717vg.jpeg\"></figure><p>Embarking on the journey of coding interviews can be both exciting and daunting. To succeed, it\u2019s crucial to focus on the right toolkit of data structures and algorithms. In this comprehensive guide, we\u2019ll explore the must-know elements that form the backbone of coding interviews:</p>\n<h4>Data Structures</h4>\n<ol>\n<li>Arrays</li>\n<li>Stacks</li>\n<li>Queues</li>\n<li>Linked Lists</li>\n<li>Trees</li>\n<li>Tries</li>\n<li>Graphs</li>\n<li>Hash Tables</li>\n</ol>\n<h4>Algorithms</h4>\n<ol>\n<li>Sorting</li>\n<li>Dynamic Programming</li>\n<li>BFS + DFS (Searching)</li>\n<li>Recursion</li>\n</ol>\n<p>There are a lot more data structures and algorithms than this. But just like when you learn a new language, you don\u2019t read through the dictionary and learn every single word in that dictionary and that language. Instead, you focus on being able to communicate with others. You only focus on things that are being used most of the\u00a0time.</p>\n<p>When it comes to data structures and algorithms, the above are the ones where you\u2019re going to be asked in interviews because these are the ones being used the most. 90% of the time to solve a real complex problem you are only going to use these. All you need is the baseline skills, and companies just want to know that you are prepared for the interview and can succeed within their\u00a0system.</p>\n<p>A lot of people complain about coding interviews or whiteboard interviews and how useless they are because they never use some of these algorithms or data structures in their day-to-day jobs. But they are just a way to weed out people who aren\u2019t willing to work hard for an interview. Look at this as an advantage, not many people work on their interview questions. You are going to work harder than 99% of people out there because you know that getting a good job will have a big impact on your\u00a0life.</p>\n<p>The good news is that it\u2019s not as hard as you think. You just have to put your time and effort into the right things. We just need to learn the right data structures &amp; algorithms, when and why to use them, how to implement them, how to solve problems with them, and make code readable, memory efficient, and time efficient using Big O. That\u2019s all coding interviews ask\u00a0for.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=04ac10678496\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["algorithms","data-structures","tech-career","interview-preparation","coding-interviews"]},{"title":"Decoding the Hiring Process: Beyond Coding Skills","pubDate":"2023-11-21 10:57:38","link":"https://medium.com/@krisalay/decoding-the-hiring-process-beyond-coding-skills-2c182ec62b9d?source=rss-207c206a9cff------2","guid":"https://medium.com/p/2c182ec62b9d","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*V8wIHQS7PAefFsF3J7qB9w.jpeg","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*V8wIHQS7PAefFsF3J7qB9w.jpeg\"></figure><p>Embarking on a job hunt in the tech industry can feel like navigating a maze of algorithms and coding challenges. While technical proficiency is undoubtedly crucial, companies are seeking more than just coding skills from their potential hires. In this blog post, we unveil the four key elements companies are looking for during interviews and shed light on why a holistic approach is the key to\u00a0success.</p>\n<h4><strong>Analytical Skills</strong></h4>\n<p>When faced with a problem, how do you approach it? Analytical skills are about more than just finding the right answer; they\u2019re about showcasing your problem-solving thought process. During interviews, companies want to witness your ability to navigate from uncertainty to a solution. Articulate your thinking, demonstrate adaptability, and showcase your analytical prowess.</p>\n<h4>Coding Skills</h4>\n<p>Coding skills remain a fundamental aspect of any tech interview. Companies are not only interested in the correctness of their code but also in its cleanliness, organization, and readability. Writing code is a form of communication, and an elegantly written codebase is a testament to your professionalism and collaborative mindset.</p>\n<h4>Technical Skills</h4>\n<p>Beyond coding, interviewers gauge your technical knowledge and understanding of fundamentals. Do you possess a deeper comprehension of the pros and cons of various solutions? Knowing the \u201cwhy\u201d behind your coding choices is crucial. Companies are looking for candidates who don\u2019t just memorize but comprehend, allowing them to make informed decisions in real-world scenarios.</p>\n<h4>Communication Skills</h4>\n<p>Your personality and communication style matter as much as your technical acumen. Working in a team requires effective communication with colleagues, managers, and other teams. Companies want to ensure that you\u2019re not only a technical asset but also a cultural fit. Showcase your ability to articulate ideas, listen actively, and collaborate seamlessly.</p>\n<p>Most people get hung up on the idea of learning every single algorithm, and data structure, doing 1000 problems to practice before an interview. These are important, but in most companies, you don\u2019t need to know how to write a binary search tree or write a sorting algorithm from scratch. Most of the time you learn it on the go on the job when you need it. Let\u2019s be honest, as engineers, we know that most of the time when a problem presents itself, we\u2019re good at searching the web on Google for answers. Not a single one of us has everything memorized in our head. Companies know this. They\u2019re not\u00a0dumb.</p>\n<p>What they\u2019re looking for are people who know how to look for answers, and they want to know that you know your data structures and you know of their existence. That\u2019s the key. They want to know when you should use a certain data structure over the other. Why should we use a certain algorithm over another? At the end of the day, companies want smart people. They want people who can solve problems that they cannot solve themselves because that\u2019s what they\u2019re paying\u00a0for.</p>\n<p>Having worked at companies and also hiring people, it's surprisingly hard to find people who can solve problems themselves without holding their hands or walking them through a problem entirely. So, when solving any data structure problems, you need to understand the <strong>\u201cwhy\u201d </strong>of doing things. Why are we learning this? Why is this the answer to this problem? Why is this answer better than the\u00a0other?</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2c182ec62b9d\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*V8wIHQS7PAefFsF3J7qB9w.jpeg\"></figure><p>Embarking on a job hunt in the tech industry can feel like navigating a maze of algorithms and coding challenges. While technical proficiency is undoubtedly crucial, companies are seeking more than just coding skills from their potential hires. In this blog post, we unveil the four key elements companies are looking for during interviews and shed light on why a holistic approach is the key to\u00a0success.</p>\n<h4><strong>Analytical Skills</strong></h4>\n<p>When faced with a problem, how do you approach it? Analytical skills are about more than just finding the right answer; they\u2019re about showcasing your problem-solving thought process. During interviews, companies want to witness your ability to navigate from uncertainty to a solution. Articulate your thinking, demonstrate adaptability, and showcase your analytical prowess.</p>\n<h4>Coding Skills</h4>\n<p>Coding skills remain a fundamental aspect of any tech interview. Companies are not only interested in the correctness of their code but also in its cleanliness, organization, and readability. Writing code is a form of communication, and an elegantly written codebase is a testament to your professionalism and collaborative mindset.</p>\n<h4>Technical Skills</h4>\n<p>Beyond coding, interviewers gauge your technical knowledge and understanding of fundamentals. Do you possess a deeper comprehension of the pros and cons of various solutions? Knowing the \u201cwhy\u201d behind your coding choices is crucial. Companies are looking for candidates who don\u2019t just memorize but comprehend, allowing them to make informed decisions in real-world scenarios.</p>\n<h4>Communication Skills</h4>\n<p>Your personality and communication style matter as much as your technical acumen. Working in a team requires effective communication with colleagues, managers, and other teams. Companies want to ensure that you\u2019re not only a technical asset but also a cultural fit. Showcase your ability to articulate ideas, listen actively, and collaborate seamlessly.</p>\n<p>Most people get hung up on the idea of learning every single algorithm, and data structure, doing 1000 problems to practice before an interview. These are important, but in most companies, you don\u2019t need to know how to write a binary search tree or write a sorting algorithm from scratch. Most of the time you learn it on the go on the job when you need it. Let\u2019s be honest, as engineers, we know that most of the time when a problem presents itself, we\u2019re good at searching the web on Google for answers. Not a single one of us has everything memorized in our head. Companies know this. They\u2019re not\u00a0dumb.</p>\n<p>What they\u2019re looking for are people who know how to look for answers, and they want to know that you know your data structures and you know of their existence. That\u2019s the key. They want to know when you should use a certain data structure over the other. Why should we use a certain algorithm over another? At the end of the day, companies want smart people. They want people who can solve problems that they cannot solve themselves because that\u2019s what they\u2019re paying\u00a0for.</p>\n<p>Having worked at companies and also hiring people, it's surprisingly hard to find people who can solve problems themselves without holding their hands or walking them through a problem entirely. So, when solving any data structure problems, you need to understand the <strong>\u201cwhy\u201d </strong>of doing things. Why are we learning this? Why is this the answer to this problem? Why is this answer better than the\u00a0other?</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2c182ec62b9d\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["analytical-thinking","coding-skills-assessment","tech-job-interview","effective-communication","technical-interview"]},{"title":"Decoding Big O Notation","pubDate":"2023-11-21 08:55:16","link":"https://medium.com/@krisalay/decoding-big-o-notation-9933c6aae774?source=rss-207c206a9cff------2","guid":"https://medium.com/p/9933c6aae774","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/340/1*a3akX_c-QQQ3NxvhQz3Gnw.png","description":"\n<h4>Unveiling Efficiency</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*a3akX_c-QQQ3NxvhQz3Gnw.png\"></figure><p>In the realm of coding efficiency, understanding Big O notation is akin to unlocking a treasure chest of insights. Today, we embark on a journey to dissect the Big O notation of a simple yet illustrative function. Brace yourself as we explore the intricacies of runtime and scalability through the lens of the findingDora function.</p>\n<h3>The Code at a\u00a0Glance:</h3>\n<p>Let\u2019s start by examining the code snippet at\u00a0hand:</p>\n<pre>const dora = [\"dora\"];<br>function findingDora(array) {<br>  for (let i = 0; i &lt; array.length; i++) {<br>    if (array[i] === 'dora') {<br>      console.log('Found Dora');<br>    }<br>  }<br>}</pre>\n<h3>The Big O Question:</h3>\n<p>What would you say if I asked, \u201cWhat is the Big O of this function?\u201d This seemingly innocent function conceals insights into its efficiency, and we\u2019re about to unravel\u00a0them.</p>\n<h3>Understanding Runtime\u00a0Growth:</h3>\n<p>In this section, we dive into the essence of runtime\u200a\u2014\u200athe time it takes for a function to run. As our input array transitions from one item to 10 items and eventually to 100K items, how does the runtime of our findingDora function evolve? What revelations can we extract about its efficiency?</p>\n<h3>Unveiling Linearity:</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*gPLhMvP3cNLSLZ0WNdlXIg.png\"></figure><p>Examining a graph of operations against the number of items in the array, a pattern emerges. With four items, we have four operations; with five items, five operations, and so forth. This linear relationship is fundamental. As the number of inputs increases, the number of operations increases proportionally.</p>\n<h3>Our First Big O Notation: O(n):</h3>\n<p>Behold, our first Big O notation\u200a\u2014\u200aO(n). The findingDora function operates in linear time. The \u2019n\u2019 in O(n) signifies that the Big O depends on the number of inputs. It\u2019s not about measuring time in seconds; instead, we focus on how rapidly our runtime grows concerning the size of the\u00a0input.</p>\n<h3>Scalability in Perspective:</h3>\n<p>Consider scalability as a measure of growth. As inputs expand, does the function scale efficiently? Drawing parallels with a compression task\u200a\u2014\u200awhere each box must undergo compression individually\u200a\u2014\u200awe understand that if the number of inputs increases, it\u2019s O(n), representing linear\u00a0time.</p>\n<h3>Conclusion and\u00a0Beyond:</h3>\n<p>Congratulations on unraveling your first Big O notation! While O(n) is a common notation, there is more to explore. Join us in the next post as we delve into additional Big O notations, enriching your understanding of coding efficiency and scalability. Get ready to dive deeper into the world of algorithmic complexities.</p>\n<h4>Previous</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/decoding-good-code-02c2156cb9a9\">Decoding Good\u00a0Code</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9933c6aae774\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h4>Unveiling Efficiency</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*a3akX_c-QQQ3NxvhQz3Gnw.png\"></figure><p>In the realm of coding efficiency, understanding Big O notation is akin to unlocking a treasure chest of insights. Today, we embark on a journey to dissect the Big O notation of a simple yet illustrative function. Brace yourself as we explore the intricacies of runtime and scalability through the lens of the findingDora function.</p>\n<h3>The Code at a\u00a0Glance:</h3>\n<p>Let\u2019s start by examining the code snippet at\u00a0hand:</p>\n<pre>const dora = [\"dora\"];<br>function findingDora(array) {<br>  for (let i = 0; i &lt; array.length; i++) {<br>    if (array[i] === 'dora') {<br>      console.log('Found Dora');<br>    }<br>  }<br>}</pre>\n<h3>The Big O Question:</h3>\n<p>What would you say if I asked, \u201cWhat is the Big O of this function?\u201d This seemingly innocent function conceals insights into its efficiency, and we\u2019re about to unravel\u00a0them.</p>\n<h3>Understanding Runtime\u00a0Growth:</h3>\n<p>In this section, we dive into the essence of runtime\u200a\u2014\u200athe time it takes for a function to run. As our input array transitions from one item to 10 items and eventually to 100K items, how does the runtime of our findingDora function evolve? What revelations can we extract about its efficiency?</p>\n<h3>Unveiling Linearity:</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*gPLhMvP3cNLSLZ0WNdlXIg.png\"></figure><p>Examining a graph of operations against the number of items in the array, a pattern emerges. With four items, we have four operations; with five items, five operations, and so forth. This linear relationship is fundamental. As the number of inputs increases, the number of operations increases proportionally.</p>\n<h3>Our First Big O Notation: O(n):</h3>\n<p>Behold, our first Big O notation\u200a\u2014\u200aO(n). The findingDora function operates in linear time. The \u2019n\u2019 in O(n) signifies that the Big O depends on the number of inputs. It\u2019s not about measuring time in seconds; instead, we focus on how rapidly our runtime grows concerning the size of the\u00a0input.</p>\n<h3>Scalability in Perspective:</h3>\n<p>Consider scalability as a measure of growth. As inputs expand, does the function scale efficiently? Drawing parallels with a compression task\u200a\u2014\u200awhere each box must undergo compression individually\u200a\u2014\u200awe understand that if the number of inputs increases, it\u2019s O(n), representing linear\u00a0time.</p>\n<h3>Conclusion and\u00a0Beyond:</h3>\n<p>Congratulations on unraveling your first Big O notation! While O(n) is a common notation, there is more to explore. Join us in the next post as we delve into additional Big O notations, enriching your understanding of coding efficiency and scalability. Get ready to dive deeper into the world of algorithmic complexities.</p>\n<h4>Previous</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/decoding-good-code-02c2156cb9a9\">Decoding Good\u00a0Code</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9933c6aae774\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["data-structures","scalable-code","software-development","big-o-notation","algorithmic-complexity"]},{"title":"Decoding Good Code","pubDate":"2023-11-21 06:46:09","link":"https://medium.com/@krisalay/decoding-good-code-02c2156cb9a9?source=rss-207c206a9cff------2","guid":"https://medium.com/p/02c2156cb9a9","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/672/1*si3WdwOTrF5ORBhSQ17QcA.png","description":"\n<h4>Readability and Scalability Unveiled</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*si3WdwOTrF5ORBhSQ17QcA.png\"></figure><p>In the intricate world of software development, the term \u201cgood code\u201d isn\u2019t merely a casual phrase; it embodies an artful fusion of readability and scalability. As we embark on this journey, take a moment to reflect on your definition of good code. Is it about clarity, elegance, or perhaps its ability to scale seamlessly with changing demands? Let\u2019s delve into the nuances of these two fundamental pillars that elevate code from functional to exceptional.</p>\n<h3>Readability: The Elegance of Clean\u00a0Code</h3>\n<p>At the heart of good code lies readability\u200a\u2014\u200athe ability of others (and your future self) to comprehend and navigate through your code effortlessly. Think of it as crafting a clear recipe for a delectable cake. Just as a well-structured recipe ensures a delicious outcome, clean and comprehensible code guarantees that your logic is transparent to those who read\u00a0it.</p>\n<h4><strong>The Foundation of Good\u00a0Code</strong></h4>\n<p>Good code, first and foremost, is about creating an environment where anyone can easily decipher the logic and intentions behind each line. Indentation, meaningful variable names, and modular structure contribute to the readability of your code. As we explore this aspect further, we\u2019ll uncover the significance of readability as the cornerstone of code\u00a0quality.</p>\n<h3>Scalability: Unveiling the Power of Big O\u00a0Notation</h3>\n<p>Beyond clarity, the second facet that defines good code is scalability. Imagine a recipe that works seamlessly whether you\u2019re baking for one or one hundred. This is where the concept of scalability in coding comes into play. And at the heart of understanding scalability lies the powerful tool known as Big O notation.</p>\n<h3>Big O Notation: The Key to Efficiency</h3>\n<p>Big O notation is the language we use to quantify the efficiency and scalability of algorithms. Much like adjusting ingredients in a recipe for different serving sizes, Big O allows us to evaluate how code performs as the input size increases.</p>\n<p>To illustrate, let\u2019s explore a JavaScript example. Consider a simple task: finding \u2018dora\u2019 in an array. The provided code snippet not only carries out this task but also serves as an introduction to measuring efficiency through runtime. We introduce the concept of runtime, or how long it takes to run a specific task through a function.</p>\n<pre>const dora = [\"dora\"];<br>function findingDora(array) {<br>  let t0 = performance.now();<br>  for (let i = 0; i &lt; array.length; i++) {<br>    if (array[i] === 'dora') {<br>      console.log('Found Dora');<br>    }<br>  }<br>  let t1 = performance.now();<br>  console.log('The function took', t1 - t0, 'milliseconds');<br>}</pre>\n<h3>Measuring Efficiency: Understanding Runtime and Big\u00a0O</h3>\n<p>To measure the performance, we use the performance API in JavaScript. As the array size increases, we observe a slowdown in the function's efficiency, prompting a crucial question: how do we determine what qualifies as good\u00a0code?</p>\n<h3>Algorithmic Efficiency: Beyond\u00a0Time</h3>\n<p>The answer lies in algorithmic efficiency. Instead of relying solely on time, we delve into measuring the number of operations a computer performs. This shift in focus becomes the crux of determining the efficiency of a function, independent of specific hardware or execution environments.</p>\n<p>As we navigate through the intricacies of algorithmic efficiency and scalable code, the discussion revolves around how many operations a function performs as the input expands. This, not time, becomes the true measure of efficiency.</p>\n<h3>Big O Notation: A Language of Efficiency</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*5VctXSES5PrSk-5lPb_CCg.jpeg\"></figure><p>While the concept of Big O notation may seem daunting at first, fear not. By the end of this section, it will be a language you speak fluently. We\u2019ll guide you through the intricacies, ensuring that you grasp the essence of algorithmic efficiency and scalable\u00a0code.</p>\n<p>In the realm of Big O and code scalability, the focus shifts to understanding how many operations a function performs as the input grows. This, not time, becomes the measure of algorithmic efficiency. Join us on this detailed exploration, and by the end, you\u2019ll be equipped to distinguish between good and exceptional code with confidence. Stay tuned for a deeper dive into the complexities of algorithmic efficiency and scalable\u00a0code.</p>\n<h4>Previous</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/big-o-asymptotic-analysis-b7cf79b0aa3d\">Big O: Asymptotic Analysis</a></p>\n<h4>Next</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/decoding-big-o-notation-9933c6aae774\">Decoding Big O\u00a0Notation</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=02c2156cb9a9\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h4>Readability and Scalability Unveiled</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*si3WdwOTrF5ORBhSQ17QcA.png\"></figure><p>In the intricate world of software development, the term \u201cgood code\u201d isn\u2019t merely a casual phrase; it embodies an artful fusion of readability and scalability. As we embark on this journey, take a moment to reflect on your definition of good code. Is it about clarity, elegance, or perhaps its ability to scale seamlessly with changing demands? Let\u2019s delve into the nuances of these two fundamental pillars that elevate code from functional to exceptional.</p>\n<h3>Readability: The Elegance of Clean\u00a0Code</h3>\n<p>At the heart of good code lies readability\u200a\u2014\u200athe ability of others (and your future self) to comprehend and navigate through your code effortlessly. Think of it as crafting a clear recipe for a delectable cake. Just as a well-structured recipe ensures a delicious outcome, clean and comprehensible code guarantees that your logic is transparent to those who read\u00a0it.</p>\n<h4><strong>The Foundation of Good\u00a0Code</strong></h4>\n<p>Good code, first and foremost, is about creating an environment where anyone can easily decipher the logic and intentions behind each line. Indentation, meaningful variable names, and modular structure contribute to the readability of your code. As we explore this aspect further, we\u2019ll uncover the significance of readability as the cornerstone of code\u00a0quality.</p>\n<h3>Scalability: Unveiling the Power of Big O\u00a0Notation</h3>\n<p>Beyond clarity, the second facet that defines good code is scalability. Imagine a recipe that works seamlessly whether you\u2019re baking for one or one hundred. This is where the concept of scalability in coding comes into play. And at the heart of understanding scalability lies the powerful tool known as Big O notation.</p>\n<h3>Big O Notation: The Key to Efficiency</h3>\n<p>Big O notation is the language we use to quantify the efficiency and scalability of algorithms. Much like adjusting ingredients in a recipe for different serving sizes, Big O allows us to evaluate how code performs as the input size increases.</p>\n<p>To illustrate, let\u2019s explore a JavaScript example. Consider a simple task: finding \u2018dora\u2019 in an array. The provided code snippet not only carries out this task but also serves as an introduction to measuring efficiency through runtime. We introduce the concept of runtime, or how long it takes to run a specific task through a function.</p>\n<pre>const dora = [\"dora\"];<br>function findingDora(array) {<br>  let t0 = performance.now();<br>  for (let i = 0; i &lt; array.length; i++) {<br>    if (array[i] === 'dora') {<br>      console.log('Found Dora');<br>    }<br>  }<br>  let t1 = performance.now();<br>  console.log('The function took', t1 - t0, 'milliseconds');<br>}</pre>\n<h3>Measuring Efficiency: Understanding Runtime and Big\u00a0O</h3>\n<p>To measure the performance, we use the performance API in JavaScript. As the array size increases, we observe a slowdown in the function's efficiency, prompting a crucial question: how do we determine what qualifies as good\u00a0code?</p>\n<h3>Algorithmic Efficiency: Beyond\u00a0Time</h3>\n<p>The answer lies in algorithmic efficiency. Instead of relying solely on time, we delve into measuring the number of operations a computer performs. This shift in focus becomes the crux of determining the efficiency of a function, independent of specific hardware or execution environments.</p>\n<p>As we navigate through the intricacies of algorithmic efficiency and scalable code, the discussion revolves around how many operations a function performs as the input expands. This, not time, becomes the true measure of efficiency.</p>\n<h3>Big O Notation: A Language of Efficiency</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*5VctXSES5PrSk-5lPb_CCg.jpeg\"></figure><p>While the concept of Big O notation may seem daunting at first, fear not. By the end of this section, it will be a language you speak fluently. We\u2019ll guide you through the intricacies, ensuring that you grasp the essence of algorithmic efficiency and scalable\u00a0code.</p>\n<p>In the realm of Big O and code scalability, the focus shifts to understanding how many operations a function performs as the input grows. This, not time, becomes the measure of algorithmic efficiency. Join us on this detailed exploration, and by the end, you\u2019ll be equipped to distinguish between good and exceptional code with confidence. Stay tuned for a deeper dive into the complexities of algorithmic efficiency and scalable\u00a0code.</p>\n<h4>Previous</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/big-o-asymptotic-analysis-b7cf79b0aa3d\">Big O: Asymptotic Analysis</a></p>\n<h4>Next</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/decoding-big-o-notation-9933c6aae774\">Decoding Big O\u00a0Notation</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=02c2156cb9a9\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["good-code","data-structures","big-o-notation","scalability","coding-efficiency"]},{"title":"Big O: Asymptotic Analysis","pubDate":"2023-11-21 03:35:56","link":"https://medium.com/@krisalay/big-o-asymptotic-analysis-b7cf79b0aa3d?source=rss-207c206a9cff------2","guid":"https://medium.com/p/b7cf79b0aa3d","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/798/1*d4dlxG1z4WFUGg1I577ZRA.png","description":"\n<h3>Big O</h3>\n<h4>Asymptotic Analysis</h4>\n<h4>Introduction</h4>\n<p>Embarking on the journey of software development, there\u2019s a crucial concept that stands tall, guiding developers towards excellence\u200a\u2014\u200athe Big O notation. In my view, this section is not just another topic in the developer\u2019s arsenal; it\u2019s the cornerstone of mastery in the field. As a software developer or engineer, irrespective of your location, company, or future endeavors, understanding Big O is paramount. It\u2019s my favorite section of the course, and for good\u00a0reason.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/798/1*d4dlxG1z4WFUGg1I577ZRA.png\"></figure><h4>The Everlasting Significance of Big\u00a0O:</h4>\n<p>Big O is a timeless concept that holds immense importance in the realm of software development. Its impact extends across industry giants like Google, Facebook, and Amazon, shaping the very core of their interview processes. You can\u2019t escape encounters with Big O in interviews, phone screenings, or any vetting process conducted by these tech titans. The reason is simple\u200a\u2014\u200aBig O is not just a passing trend but a fundamental concept that contributes to making you a better developer and engineer.</p>\n<h4>Unveiling the Essence of Big\u00a0O</h4>\n<p>Given enough time, any coder can solve a problem, but what truly matters is how well the problem is solved. Enter Big O. This notation becomes our guiding light, revealing the efficiency with which a problem is tackled. In this section, we will delve into the intricacies of Big O, understanding its definition and various notations. This knowledge will empower us to differentiate between good code and great code, setting us on a path toward becoming exceptional developers.</p>\n<h4>A Skill for a\u00a0Lifetime</h4>\n<p>The beauty of Big O lies in its enduring relevance. Learning and mastering Big O isn\u2019t just about acing interviews; it forms the bedrock of a developer\u2019s prowess. By becoming adept at this notation, we not only navigate interviews with confidence but also establish a strong foundation for delving into more advanced topics like data structures and algorithms.</p>\n<h4>Building Comfort, Breaking Surprises</h4>\n<p>Our journey through this course aims to familiarize us with Big O to the extent that encountering it in interviews becomes second nature. We are not just preparing for specific scenarios; we are laying the groundwork for a holistic understanding that will serve us throughout our\u00a0careers.</p>\n<h4>Conclusion</h4>\n<p>As we kick off this course with Big O, let\u2019s embrace it as more than just a section in the curriculum. Let\u2019s recognize it for what it truly is\u200a\u2014\u200aa key that unlocks the doors to excellence in software development. Whether you\u2019re a novice or a seasoned coder, the journey through Big O is a journey towards becoming an exceptional developer, equipped with the skills that transcend time and trends. So, let\u2019s dive in and unravel the power of Big O notation, setting the stage for a fulfilling and successful career in the world of software development.</p>\n<h4>Next</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/decoding-good-code-02c2156cb9a9\">Decoding Good Code: Readability and Scalability Unveiled</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b7cf79b0aa3d\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Big O</h3>\n<h4>Asymptotic Analysis</h4>\n<h4>Introduction</h4>\n<p>Embarking on the journey of software development, there\u2019s a crucial concept that stands tall, guiding developers towards excellence\u200a\u2014\u200athe Big O notation. In my view, this section is not just another topic in the developer\u2019s arsenal; it\u2019s the cornerstone of mastery in the field. As a software developer or engineer, irrespective of your location, company, or future endeavors, understanding Big O is paramount. It\u2019s my favorite section of the course, and for good\u00a0reason.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/798/1*d4dlxG1z4WFUGg1I577ZRA.png\"></figure><h4>The Everlasting Significance of Big\u00a0O:</h4>\n<p>Big O is a timeless concept that holds immense importance in the realm of software development. Its impact extends across industry giants like Google, Facebook, and Amazon, shaping the very core of their interview processes. You can\u2019t escape encounters with Big O in interviews, phone screenings, or any vetting process conducted by these tech titans. The reason is simple\u200a\u2014\u200aBig O is not just a passing trend but a fundamental concept that contributes to making you a better developer and engineer.</p>\n<h4>Unveiling the Essence of Big\u00a0O</h4>\n<p>Given enough time, any coder can solve a problem, but what truly matters is how well the problem is solved. Enter Big O. This notation becomes our guiding light, revealing the efficiency with which a problem is tackled. In this section, we will delve into the intricacies of Big O, understanding its definition and various notations. This knowledge will empower us to differentiate between good code and great code, setting us on a path toward becoming exceptional developers.</p>\n<h4>A Skill for a\u00a0Lifetime</h4>\n<p>The beauty of Big O lies in its enduring relevance. Learning and mastering Big O isn\u2019t just about acing interviews; it forms the bedrock of a developer\u2019s prowess. By becoming adept at this notation, we not only navigate interviews with confidence but also establish a strong foundation for delving into more advanced topics like data structures and algorithms.</p>\n<h4>Building Comfort, Breaking Surprises</h4>\n<p>Our journey through this course aims to familiarize us with Big O to the extent that encountering it in interviews becomes second nature. We are not just preparing for specific scenarios; we are laying the groundwork for a holistic understanding that will serve us throughout our\u00a0careers.</p>\n<h4>Conclusion</h4>\n<p>As we kick off this course with Big O, let\u2019s embrace it as more than just a section in the curriculum. Let\u2019s recognize it for what it truly is\u200a\u2014\u200aa key that unlocks the doors to excellence in software development. Whether you\u2019re a novice or a seasoned coder, the journey through Big O is a journey towards becoming an exceptional developer, equipped with the skills that transcend time and trends. So, let\u2019s dive in and unravel the power of Big O notation, setting the stage for a fulfilling and successful career in the world of software development.</p>\n<h4>Next</h4>\n<p><a href=\"https://medium.com/@krisalay.kumar/decoding-good-code-02c2156cb9a9\">Decoding Good Code: Readability and Scalability Unveiled</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b7cf79b0aa3d\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["coding-efficiency","software-development","algorithmic-complexity","big-o-notation","data-structures"]},{"title":"Using Thynogger, a versatile logging library for Node.js","pubDate":"2020-08-24 13:08:01","link":"https://medium.com/@krisalay/using-thynogger-a-versatile-logging-library-for-node-js-5be253854212?source=rss-207c206a9cff------2","guid":"https://medium.com/p/5be253854212","author":"Krisalay","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*jiSNp5YYU804wLLyKzVRcQ.png","description":"\n<blockquote>Today, we will explore Thynogger, a versatile logging library for Node.js built on top of winston. Thynogger can be used in numerous contexts including in Node web frameworks such as Express, and Node CLI apps. This article has been updated to reflect the latest generation of Thynogger at the time of this writing which is Thynogger 1.x.</blockquote>\n<p>Thynogger is a simple and easy to use logging package for better readability in the consoles or terminals. The terminal/console logs can be piped into the file and converted into the CSV file by changing the delimiter to pipe ( | )\u00a0symbol.</p>\n<h3>Getting started with Thynogger</h3>\n<p>Let\u2019s first create a new project folder so we can take Thynogger for a test drive. I recommend that you choose a directory name such as <em>thynogger-test</em> to ensure that npm does not yield an error and refuse to install a package as a dependency of\u00a0itself.</p>\n<p>Next, create a blank package.json file that automatically accepts all the defaults without prompting you. (We are, after all, just creating a quick test project.)</p>\n<pre>$ npm init -y</pre>\n<p>We are now positioned to install Thynogger and save it as a dependency in our package.json file:</p>\n<pre>$ npm install --save thynogger</pre>\n<p>Create a file called index.js and add the following contents:</p>\n<a href=\"https://medium.com/media/23be34c5f0257d1a866942139f66b303/href\">https://medium.com/media/23be34c5f0257d1a866942139f66b303/href</a><p>Next, run the program you just created from the\u00a0console:</p>\n<pre>$ node index.js</pre>\n<p>You should see the following output:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*jiSNp5YYU804wLLyKzVRcQ.png\"></figure><p>Success\u200a\u2014\u200ayou are logging messages to the\u00a0console!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5be253854212\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<blockquote>Today, we will explore Thynogger, a versatile logging library for Node.js built on top of winston. Thynogger can be used in numerous contexts including in Node web frameworks such as Express, and Node CLI apps. This article has been updated to reflect the latest generation of Thynogger at the time of this writing which is Thynogger 1.x.</blockquote>\n<p>Thynogger is a simple and easy to use logging package for better readability in the consoles or terminals. The terminal/console logs can be piped into the file and converted into the CSV file by changing the delimiter to pipe ( | )\u00a0symbol.</p>\n<h3>Getting started with Thynogger</h3>\n<p>Let\u2019s first create a new project folder so we can take Thynogger for a test drive. I recommend that you choose a directory name such as <em>thynogger-test</em> to ensure that npm does not yield an error and refuse to install a package as a dependency of\u00a0itself.</p>\n<p>Next, create a blank package.json file that automatically accepts all the defaults without prompting you. (We are, after all, just creating a quick test project.)</p>\n<pre>$ npm init -y</pre>\n<p>We are now positioned to install Thynogger and save it as a dependency in our package.json file:</p>\n<pre>$ npm install --save thynogger</pre>\n<p>Create a file called index.js and add the following contents:</p>\n<a href=\"https://medium.com/media/23be34c5f0257d1a866942139f66b303/href\">https://medium.com/media/23be34c5f0257d1a866942139f66b303/href</a><p>Next, run the program you just created from the\u00a0console:</p>\n<pre>$ node index.js</pre>\n<p>You should see the following output:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*jiSNp5YYU804wLLyKzVRcQ.png\"></figure><p>Success\u200a\u2014\u200ayou are logging messages to the\u00a0console!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5be253854212\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["winston","thynogger","nodejs","logs","logger"]}]}